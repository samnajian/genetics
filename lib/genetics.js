// Generated by CoffeeScript 1.7.1
var Genetic, Solution;

Solution = (require('./sol')).Solution;

Genetic = (function() {
  function Genetic(SolType, totalPop, keepPop, crossover) {
    this.SolType = SolType;
    this.totalPop = totalPop != null ? totalPop : 100;
    this.keepPop = keepPop != null ? keepPop : 0;
    this.crossover = crossover != null ? crossover : 0.5;
    if (this.keepPop === 0) {
      this.keepPop = this.totalPop / 2;
    }
    this.pop = new Array;
    return;
  }

  Genetic.prototype.init = function() {
    var i, newSol, _i, _ref;
    for (i = _i = 1, _ref = this.totalPop; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      newSol = new this.SolType;
      newSol.random();
      newSol.gen = 0;
      this.pop.push(newSol);
    }
  };

  Genetic.prototype.sort = function() {
    this.pop.sort(function(a, b) {
      return b.fit - a.fit;
    });
  };

  Genetic.prototype.bestfit = function() {
    this.sort();
    return this.pop[0];
  };

  Genetic.prototype["eval"] = function() {
    var sol, _i, _len, _ref, _results;
    _ref = this.pop;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sol = _ref[_i];
      _results.push(sol["eval"]());
    }
    return _results;
  };

  Genetic.prototype.random = function() {
    var rand;
    rand = Math.round((Math.random() * 100000) % (this.pop.length - 1));
    return this.pop[rand];
  };

  Genetic.prototype.totalFit = function() {
    var ret, sol, _i, _len, _ref;
    ret = 0;
    _ref = this.pop;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sol = _ref[_i];
      ret += sol.fit;
    }
    return ret;
  };

  Genetic.prototype.rws = function(f) {
    var ptr, sol, _i, _len, _ref;
    if (f == null) {
      f = null;
    }
    if (f === null) {
      f = Math.round(Math.random() * 1000000) % this.totalFit();
    }
    if (f === -1) {
      f = Math.random();
    }
    ptr = 0;
    _ref = this.pop;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sol = _ref[_i];
      if (ptr < f && ptr + sol.fit > f) {
        return sol;
      }
      ptr += sol.fit;
    }
    return this.pop[0];
  };

  Genetic.prototype.selectRWS = function(k) {
    var i, newPop, _i, _ref;
    if (k == null) {
      k = null;
    }
    this.sort();
    newPop = new Array;
    for (i = _i = 1, _ref = this.totalPop; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      newPop.push(this.rws(k));
    }
    this.pop = newPop;
  };

  Genetic.prototype.selectRWS2 = function() {
    this.selectRWS(-1);
  };

  Genetic.prototype.selectSUS = function() {
    var f, i, newPop, ptrs, start, totalFit, _i, _j, _len, _ref;
    totalFit = this.totalFit();
    start = (Math.random() * 1000) % (totalFit / this.totalPop);
    ptrs = new Array;
    for (i = _i = 0, _ref = this.totalPop - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      ptrs.push(start + i * (totalFit / this.totalPop));
    }
    newPop = new Array;
    for (_j = 0, _len = ptrs.length; _j < _len; _j++) {
      f = ptrs[_j];
      newPop.push(this.rws(f));
    }
    this.pop = newPop;
  };

  Genetic.prototype.run = function() {
    var i, need1, need2, needed, newPop, newSol, npop, oldPop, sol, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _ref, _ref1, _ref2;
    _ref = this.pop;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sol = _ref[_i];
      sol["eval"]();
    }
    this.gen = 0;
    while (true) {
      if (this.end()) {
        this.gen--;
        return;
      }
      needed = this.totalPop - this.keepPop;
      need1 = Math.round(needed * this.crossover);
      need2 = needed - need1;
      npop = new Array;
      this.sort();
      for (i = _j = 0, _ref1 = this.keepPop - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        npop.push(this.pop[i]);
      }
      this.pop = npop;
      newPop = new Array;
      for (i = _k = 1; 1 <= need1 ? _k <= need1 : _k >= need1; i = 1 <= need1 ? ++_k : --_k) {
        newSol = new this.SolType;
        newSol.crossOver(this.random(), this.random());
        newSol.gen = this.gen;
        newPop.push(newSol);
      }
      for (i = _l = 1; 1 <= need2 ? _l <= need2 : _l >= need2; i = 1 <= need2 ? ++_l : --_l) {
        newSol = this.random().mutate();
        newSol.gen = this.gen;
        newPop.push(newSol);
      }
      for (_m = 0, _len1 = newPop.length; _m < _len1; _m++) {
        sol = newPop[_m];
        sol["eval"]();
      }
      for (_n = 0, _len2 = newPop.length; _n < _len2; _n++) {
        sol = newPop[_n];
        this.pop.push(sol);
      }
      if (this.select) {
        this.select(this.totalPop);
        if (this.pop.length !== this.totalPop) {
          throw "Select method failed";
        }
      } else {
        this.sort();
        oldPop = this.pop;
        this.pop = new Array;
        for (i = _o = 0, _ref2 = this.totalPop - 1; 0 <= _ref2 ? _o <= _ref2 : _o >= _ref2; i = 0 <= _ref2 ? ++_o : --_o) {
          this.pop.push(oldPop[i]);
        }
        oldPop = null;
      }
      this.gen++;
    }
  };

  return Genetic;

})();

exports.Genetic = Genetic;

exports.Solution = Solution;
