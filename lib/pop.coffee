
Solution = (datas = null, gen = 0, fit = -1) ->
  throw "Can't create Solution" if datas is null
  this.datas  = datas
  this.gen    = gen
  this.fit    = fit
  return this

gn_pop_init = (n, fun = null) ->
  fun = this.initFun if fun is null
  throw "Can't init population" if fun is null
  this.add fun() for i in [1..n]
  return

gn_pop_add = (data, gen = 0) ->
  this.pop.push new Solution data, gen
  return

gn_pop_set_init_fun = (fun) ->
  this.initFun = fun
  return

gn_pop_set_fit_fun = (fun) ->
  this.fitFun = fun
  return

gn_pop_eval = ->
  throw "Can't eval population" if this.fitFun is null
  indiv.fit = this.fitFun indiv.datas for indiv, i in this.pop
  return

best = 0

gn_pop_best_fn = (sol, ret) ->
  if sol.fit > best
    best = sol.fit
    return sol
  return ret

gn_pop_best = ->
  ret = null
  best = -1
  (ret = gn_pop_best_fn sol, ret) for sol in this.pop
  return ret

gn_pop_sort_fn = (a, b) ->
  return b.fit - a.fit

gn_pop_sort = ->
  this.pop = this.pop.sort gn_pop_sort_fn
  return

gn_pop_select_best_fit = (n) ->
  this.eval()
  this.sort()
  max = (Math.round this.pop.length * (n / 100)) - 1
  this.pop = this.pop[0..max]
  return

gn_pop_select_fit = (fit) ->
  tmp = new Array
  (tmp.push sol if sol.fit >= fit) for sol in this.pop
  this.pop = tmp
  return

gn_pop_select_prob = (prob) ->
  tmp = new Array
  (tmp.push sol if Math.random() <= prob) for sol in this.pop
  this.pop = tmp
  return

gn_pop_get_fit_sum = ->
  sum = 0
  sum += sol.fit for sol in this.pop
  return sum

gn_pop_get_fit_prob = (sol) ->
  return sol.fit / this.getFitSum()

gn_pop_select_fit_prob = (n) ->
  throw "Can't select" if n < this.pop.length
  tmp = new Array
  while tmp.length < n
    (tmp.push sol if Math.random() <= this.getFitProb(sol)) for sol in this.pop
  this.pop = tmp
  return

gn_pop_tournament_fn = (tour, pop, max) ->
  rand = Math.round((Math.random() * 1000) % max)
  tour.push pop[rand]
  return

gn_pop_tournament = (k) ->
  tournament = new Array
  max = this.pop.length - 1
  gn_pop_tournament_fn tournament, this.pop, max for i in [1..k]
  tournament.sort (a, b) ->
    return b.fit - a.fit
  return tournament[0]

gn_pop_select_tournament = (n, k) ->
  tmp = new Array
  (tmp.push this.tournament k) for i in [1..n]
  this.pop = tmp
  return

gn_pop_roulette_fn = (pop, i = 0) ->
  if i + 1 == pop.length
    return pop[i].p
  pop[i].p += gn_pop_roulette_fn pop, i + 1
  return pop[i].p

gn_pop_roulette = () ->
  (sol.p = this.getFitProb sol) for sol in this.pop
  gn_pop_roulette_fn this.pop
  rand = Math.random()
  max = this.pop.length - 1
  ret = null
  for i in [max..0]
    ret = this.pop[i] if rand < this.pop[i].p and ret is null
  return ret

gn_pop_select_roulette = (n) ->
  tmp = new Array
  tmp.push this.roulette() for i in [1..n]
  this.pop = tmp
  return

gn_pop_set_select = (fun) ->
  this.select = fun
  return

gn_pop_get_random_sol = ->
  rand = Math.round((Math.random()*2*this.pop.length)%this.pop.length)
  return this.pop[rand]

Pop = ->
  this.pop              = new Array
  this.initFun          = null
  this.fitFun           = null
  this.select           = null

  # implemented select functions are :
  #   selectFitProb(n)
  #   selectRoulette(n)

  # init(n, fun)
  #   add n Solution to the population generated by the fun argument
  #   the fun argument must return a random solution
  # init(n)
  #   add n Solution to the population 
  #   generated by initFun function (setted by setInitFun)
  this.init             = gn_pop_init

  # add(data)
  #   add a solution to the population
  this.add              = gn_pop_add

  # setInitFun(fun)
  #   set the initFun function used by init(n) to generate Solutions
  #   initFun must return a random solution
  this.setInitFun       = gn_pop_set_init_fun

  # setFitnessFun(fun)
  #   set the fitnessFun function used to rate a solution
  #   the fun arguments must be a function taking a solution
  #   and returning a number
  this.setFitnessFun    = gn_pop_set_fit_fun

  # eval()
  #   evaluate the population using the fitnessFun function
  this.eval             = gn_pop_eval

  # sort()
  #   sort the population by fitness
  this.sort             = gn_pop_sort

  # best()
  #   return the best solution
  this.best             = gn_pop_best

  # selectBestFit(n)
  #   select the n% best solutions
  this.selectBestFit    = gn_pop_select_best_fit

  # selectFit(fit)
  #   select solutions with fitness over fit
  this.selectFit        = gn_pop_select_fit

  # selectProb(prob)
  #   select solutions with a probability under prob
  this.selectProb       = gn_pop_select_prob

  # getFitSum()
  #   return the sum of fitness
  this.getFitSum        = gn_pop_get_fit_sum

  # getFitProb(sol)
  #   return probability for solution
  this.getFitProb       = gn_pop_get_fit_prob

  # selectFitProb(n)
  #   select n solutions by fitProb
  this.selectFitProb    = gn_pop_select_fit_prob

  # tournament(k)
  #   return solution from tournament of size k
  this.tournament       = gn_pop_tournament

  # selectTournament(n, k)
  #   select n solutions by tournament of size k
  this.selectTournament = gn_pop_select_tournament

  # roulette()
  #   return solution from roulette selection
  this.roulette         = gn_pop_roulette

  # selectRoulette(n)
  #   select n solutions by roulette selection
  this.selectRoulette   = gn_pop_select_roulette

  # setSelect(fun)
  #   set function used for selection
  this.setSelect        = gn_pop_set_select

  # getRandomSol()
  #   return a random solution from pop
  this.getRandomSol     = gn_pop_get_random_sol

  return this

exports.Solution  = Solution
exports.Pop       = Pop

